<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Bootstrap Navbar Sidebar - Fixed to Left or Right</title>
    <link rel="stylesheet"
          id="theme_link"
          href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/4.3.1/materia/bootstrap.min.css"/>
    <link rel="stylesheet" href="./css/navbar-fixed-right.min.css">
    <link rel="stylesheet" href="./css/navbar-fixed-left.min.css">
    <link rel="stylesheet" href="./css/docs.css">
    <script
            src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
            integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8="
            crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
            integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
            crossorigin="anonymous"></script>
    <script src="./css/docs.js"></script>
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <style>
        pre {
            display: inline-block;
            background-color: black;
            border-radius: 3px;
            padding: 0.1em 0.2em;
            color: royalblue;
        }
        img {
            width: "10px";
            height: "10px";
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand-md navbar-dark bg-primary fixed-top p-1 ">
        <a class="navbar-brand" href>SpringBatch学習メモ</a>
        <div class="collapse navbar-collapse " style="line-height: 0.5em"> 
            <ul class="navbar-nav" >
                <li class="nav-item">
                    <a class="nav-link" href="#1">1.はじめに</a>
                    <ul>
                        <a class="nav-link" href="#1-1">1-1.SpringのDIについて</a>
                        <a class="nav-link" href="#1-2">1-2.SpringBatchの概要</a>
                    </ul>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#2">2.環境構築</a>
                    <ul>
                        <a class="nav-link" href="#2-1">2-1.Postgresqlインストール</a>
                        <a class="nav-link" href="#2-2">2-2.DB構築</a>
                        <a class="nav-link" href="#2-3">2-3.プロジェクトの作成</a>
                        <a class="nav-link" href="#2-4">2-4.GitHubに登録</a>
                    </ul>
                    <a class="nav-link" href="#3">3.サンプルアプリ作成</a>
                    <ul>
                        <a class="nav-link" href="#3-1">3-1.Taskletの作成</a>
                        <a class="nav-link" href="#3-2">3-2.Chunkの作成</a>
                    </ul>
                </li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <h1 id="1">1.はじめに</h1>
        <p>SpringBatchの前提知識は以下の通り。</p>
        <ul>
            <h2 id="1-1">1-1.SpringのDIについて</h2>
            <p>
                DI(Dependancy Injection)とは、インスタンスを変数に代入すること。
                    <br><br>
                    [DIの例]
                    <br>
                    <pre class="pre-scrollable"><code>
    puclic class Hoge {
        private job = new testJob();
    }
                    </code></pre>
                    <br>
                    上記の例では、testJobのインスタンスを生成し、jobに代入している。
                    testJobを利用した一通りのテストが完了し、testJobからprobJonに切り替えを行う場合は、依存クラスを変更する目的でコードを改修する必要がある。                    
                    <br><br>
                    SpringのDIは、この問題を解決するために、インスタンスの生成と変数への代入を自動管理する機能を提供している。
                    SpringのDIを利用すると、上記の例は以下のようなコードとなる。
                    <br><br>
                    [SpringによるDIの例]
                    <br>
                    <pre class="pre-scrollable"><code>
    @Component
    puclic class TestJob implements Job {
        ...
    }
    @Component
    public class Hoge{
        @Autowired
        private Job job;
    }
                    </code></pre>
                    <br>
                    @Componentで、Jobインターフェースを実装したTestJobをDIコンテナにBeanとして登録する。
                    これにより、SpringによりJobクラスのインスタンス生成が管理される。
                    <br>
                    @Autowiredで、JobインスタンスをDIしている。このコードはSpringで管理されるため、newの記述が不要となる。
                    <br>
                    testJobからprobJobに切り替えを行う際は、TestJobの代わりにprobJobをBean登録する。
                    Hogeクラスの改修は不要となる。
                    <br><br>
                    上記の通り、SpringはBean登録されたクラスについて、インスタンス生成の管理を行う。
                    このライフサイクルは、Bean登録のコードに@Scope(~)を付与することで設定する。
                    <br><br>
                    <table class="table">
                        <tr>
                            <th>スコープ</th>
                            <th>説明</th>
                        </th>
                        <tr>
                            <td>@Scope("singleton")</td>
                            <td>
                                Spring起動時にインスタンスを1つだけ生成する。Springを停止するまで、このインスタンスを使いまわす。
                                Scopeアノテーションを付与しない場合はデフォルトでこの設定となる。
                            </td>
                        </tr>
                        <tr>
                            <td>@Scope("prototype")</td>
                            <td>@AutowiredでDIする度に新しいインスタンスの生成と破棄を行う。</td>
                        </tr>
                    </table>
                    <br>
                    まとめると、SpringのDIは以下のような動きをする。
                    <br><br>
                    <ol>
                        <li>@Componentなどがついたクラスを起動時に探す。(ComponentScan)</li>
                        <li>ヒットしたクラスをBeanとしてDIコンテナに登録する。</li>
                        <li>Scopeの設定に従い、インスタンスのライフサイクル管理を行う。</li>
                        <li>@Autoriredが付与された箇所にインスタンスを代入する。</li>
                    </ol>
            </p>
        </ul>
        <ul>
            <h2 id="1-2">1-2.SpringBatchの概要</h2>
            <p>
                SpringBatchはSpringを使ってバッチアプリケーションを開発するためのフレームワーク。
                DI、バリデーション、DBアクセスなどSpringが標準で提供する機能に加えて、ファイルやDBの読み込み、書き込み、ジョブ管理など、バッチがよく利用する機能もサポートされる。
                <br><br>
                SpringBatchのアーキテクチャは以下の通りとなる。
                <br><br>
                <img class="img-fluid" src="./image/springBatch-arc.png" alt="SpringBatchのアーキテクチャ" title="SpringBatchのアーキテクチャ">
                <br><br>
                <table class="table">
                    <tr>
                        <th>項目</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td>JobRepository</td>
                        <td>
                            バッチの実行結果をDBに保存してくれる機能
                        </td>
                    </tr>
                    <tr>
                        <td>JobLauncher</td>
                        <td>
                            バッチを実行するトリガー機能
                        </td>
                    </tr>
                    <tr>
                        <td>Job</td>
                        <td>
                            バッチの全体を構成している管理単位
                        </td>
                    </tr>
                    <tr>
                        <td>Step</td>
                        <td>
                            バッチの最小単位。一つのJobで複数のStepの実行フローを管理する。
                        </td>
                    </tr>
                </table>
                <br>
                Stepには、以下の2種類のモデルがあり、バッチの用途で使い分ける。

                <table class="table">
                    <tr>
                        <th>項目</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td>Chunk</td>
                        <td>データの読み込み、加工、書き込みという一般的なバッチ処理のフレームワークを提供してくれるモデル。
                            <br>
                            各処理はChunkが提供する以下のインターフェースを実装する。
                            <br>
                            <ul>
                             <li>ItemReader : データの読み込み</li>
                             <li>ItemProcessor : データの加工</li>
                             <li>ItemWriter : データの書き込み</li>
                            </ul>
                        </td>
                    </tr>
                    <tr>
                        <td>Tasklet</td>
                        <td>
                            Chunkで対応出来合い機能を実装する場合に利用する。
                        </td>
                    </tr>
                </table>
            </p>
        </ul>
        <h1 id="2">2.環境構築</h1>
        <p>本章ではSpringBatchを開発を行うための環境構築のメモを記載する。</p>
        <ul>
            <h2 id="2-1">2-1.PostgreSQLのインストール</h2>
            <p>
                以下のサイトからPostgreSQLをダウンロードする。
                <br>
                ※執筆時点で最新版の14.1（Windows版)をダウンロードした。
                <br>
                <a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads">
                    https://www.enterprisedb.com/downloads/postgres-postgresql-downloads
                </a>
                <br>
                ダウンロード後、以下の手順でインストールする。
                <ol>
                    <li>ダウンロードしたexeファイルをダブルクリックする。</li>
                    <li>ウィザードが起動したら、Nextを押下する。</li>
                    <li>インストール先のパスを指定する。ここでは、「C:\PostgreSQL\14」を指定した。</li>
                    <li>全てのコンポーネントがチェックされていることを確認してNextを押下する。</li>
                    <li>データ格納フォルダを指定する。ここでは「C:\PostgreSQL\14\data」を指定した。</li>
                    <li>特権ユーザ(postgres)のパスワード設定する。ここでは「postgres」を指定した。</li>
                    <li>ポートを指定する。デフォルトのここでは「5432」を指定した。</li>
                    <li>ロケールを設定するここではデフォルト設定のままにした。</li>
                    <li>インストール情報のサマリが出力されるため、想定通りであることを確認し、Nextを押下する。</li>
                    <li>もう一度Nextを押下するとインストールが開始される。</li>
                    <li>しばらくするとウィザード上にFinishと表示されるのでクリックする。</li>
                    <li>追加パッケージをインストールするためのスタックビルダが表示されるが、デフォルト構成で利用するため、キャンセルする。</li>
                </ol>
            </p>
        </ul>
        <ul>
            <h2 id="2-2">2-2.DBの構築</h2>
                <P>
                    以下の手順で、SpringBatchで利用するDBの設定を行う。
                    <ol>
                        <li>
                            スタート→PostgreSQL→pgAdminでpgAdminを起動する。
                            <br>
                            ※pgAdminはPostgreSQLの管理コンソール
                        </li>
                        <li>起動後、インストール時に設定したパスワードを入力する。</li>
                        <li>
                            Servers→Login/Groups Roles→Create→Login/Group Roleを押下する。
                            <br><br>
                            <img class="img-fluid" src="image/pa-create-user.png">
                            <br><br>
                        </li>
                        <li>Generalタブでユーザ名をspringBatchに設定する。</li>
                        <li>Definitionタブでパスワードを設定する。ここでは、「springBatch」とした。</li>
                        <li>
                            Privilegesタブで以下の通り、権限設定をする。
                            <br><br>
                            <img class="img-fluid" src="image/pa-create-user-privileges.png">
                            <br><br>
                        </li>
                        <li>Saveを押下し、ユーザ作成を完了する。</li>
                        <li>
                            Database→Create→Database...をクリックする。
                            <br><br>
                            <img class="img-fluid" src="image/pa-create-database.png">
                            <br><br>
                        </li>
                        <li>GeneralタブでDatabase名をspringBatchとする。</li>
                        <li>Generalタブでデータベースのownerを先ほど作成したユーザ(springBatch)にする。</li>
                        <li>Saveを押下し、データベース作成を完了する。</li>
                        <li>
                            作成したデータベース(springBatch)を右クリック→QueryToolをクリックする。
                            <br><br>
                            <img class="img-fluid" src="image/pa-create-table.png">
                            <br><br>
                        </li>
                        <li>
                            以下のSQL文を実行し、テーブルを作成する。
                            <br>
                            ※SQL文の実行は、F5で出来る。
                            <br>
                            <pre class="pre-scrollable"><code>
    Create TABLE IF NOT EXISTS employee(
    	id INT PRIMARY KEY,
    	name VARCHAR(50),
    	age INT,
    	gender INT
    );
                            </code></pre>
                        </li>
                        <li>
                            作成したデータベース(springBatch)→Schemas→Tablesを右クリックし、Refreshする。
                            <br>
                            テーブルが作成されたことを確認できる。
                            <br><br>
                            <img class="img-fluid" src="image/pa-create-table2.png">
                            <br><br>
                        </li>
                        <li>同様にspringBatch2テーブルも作成する。</li>
                    </ol>
                </P>
        </ul>
        <ul>
            <h2 id="2-3">2-3.プロジェクトの作成</h2>
            <p>
                STS上でSpringBatchアプリケーション用のプロジェクトを作成する。
                <br>
                ※Lombock含めたSTSの設定は実施済みの前提とする。
                <br>
                <ol>
                    <li>
                        SpringBatchアプリケーション用のワークスペースを設定し、STSを起動する。
                        <br><br>
                        <img class="img-fluid" src="image/sts-create-project1.png">
                        <br><br>
                    </li>
                    <li>
                        プロジェクトの作成を行う。
                        <br><br>
                        <img class="img-fluid" src="image/sts-create-project2.png">
                        <br><br>
                    </li>
                    <li>
                        Springスターター・プロジェクトを選択する。
                        <br><br>
                        <img class="img-fluid" src="image/sts-create-project3.png">
                        <br><br>
                    </li>
                    <li>
                        プロジェクト名を「SpringBatchSample」とする。その他はデフォルト設定のままで次へを押下する。
                        <br><br>
                        <img class="img-fluid" src="image/sts-create-project4.png">
                        <br><br>
                    </li>
                    <li>
                        追加するライブラリを選択し、完了する。
                        <br><br>
                        <img class="img-fluid" src="image/sts-create-project5.png">
                        <br><br>
                        追加したライブラリは以下の通り。
                        <br><br>
                        <table class="table">
                            <tr>
                                <th>分類</th>
                                <th>ライブラリ</th>
                            </tr>
                            <tr>
                                <td rowspan="2">開発ツール</td>
                                <td>Spring Boot DevTools</td>
                            </tr>
                            <tr>
                                <td>Lombock</td>
                            </tr>
                            <tr>
                                <td>I/O</td>
                                <td>Spring Batch</td>
                            </tr>
                            <tr>
                                <td rowspan="3">SQL</td>
                                <td>JDBC API</td>
                            </tr>
                            <tr><td>Spring Data JDBC</td></tr>
                            <tr><td>H2 Database</td></tr>
                        </table>
                    </li>
                </ol>
            </p>
            <br><br>
            (2021年11月22日追記)
            <br>
            上記手順でSpringBatchのプロジェクトを作成したところ、入門コンテンツのインポートが79%まで進んだところで止まってしまい、プロジェクトの作成が完了しないことが気が付いた。
            <a href="https://teratail.com/questions/361070">STSのバグの模様。</a>
            <br>
            代わりに以下手順でプロジェクトを作成した。
            <ol>
                <li>
                    <a href="https://start.spring.io/">spring initilizer</a>で、プロジェクトを作成し、ZIPファイルをダウンロード
                    <br>
                    ※プロジェクト情報は、上記でSpring プロジェクト・スターターを利用した際と同様のものを利用
                </li>
                <li>ダウンロードしたzipファイルを解凍</li>
                <li>解凍したフォルダで、<code>mvn spring-boot:run</code>を実行</li>
                <li>正常にビルド出来たことを確認後、STSから既存Mavenプロジェクトとしてインポート</li>
            </ol>
        </ul>
        <ul>
            <h2 id="2-4">2-4.GitHubに登録</h2>
            <p>
                以下手順で作成したプロジェクトをGitHubに登録する。
                <ol>
                    <li>GitHub上に新規リポジトリを作成する。</li>
                    <li>
                        STS起動時に作成したワークスペース配下のSpringBatchSampleにコマンドプロンプトで移動し、以下のコマンドを実行する。
                        <pre class="pre-scrollable"><code>
    git init
    echo "# Study Spring Boot" >> README.md
    git add .
    git commit -m "first commit"
    git remote add origin git@github.com:yushin1402/SpringBatch.git
    git push -u origin master
                        </code></pre>
                    </li>
                    <li>
                        GitHubのリポジトリ上にコミットされたことを確認する。
                        <br><br>
                        <img class="img-fluid" src="image/git-commit1.png">
                        <br><br>
                    </li>
                    <li>
                        GitHubのリポジトリページ上部のSettingを押下する。
                        <br>
                        GitHub Pagesの項目でClick it out hereをクリックし、設定ページに移動する。
                        <br><br>
                        <img class="img-fluid" src="image/git-commit2.png">
                        <br><br>
                    </li>
                    <li>
                        SourceをBranche:masterの/rootに指定する。(/docをドキュメントの置き場所にしたほうが良かったか。。。)
                        <br>
                        このままSaveする。
                        <br><br>
                        <img class="img-fluid" src="image/git-commit3.png">
                        <br><br>
                    </li>
                    <li>しばらく待った後、「https://yushin1402.github.io/SpringBatch/index.html」にアクセスすると本ページ(index.html)が公開されていることを確認出来る。</li>
                </ol>
            </p>
        </ul>
        <h1 id="3">3.サンプルアプリの作成</h1>
        <p>
            ログ出力を行う簡単なサンプルアプリの作成を行う。
            <ul>
                <h2 id="3-1">3-1.taskletの作成</h2>
                ログに「Hello World」を出力するバッチをtaskletで作成する。
                <br><br>
                [編集するファイル]
                <br>
                <table class="table">
                    <tr>
                        <th>ファイル名</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td>com.example.batch.config</td>
                        <td>src/main/java配下に左記パッケージを作成する。</td>
                    </tr>
                    <tr>
                        <td>BatchConfig.java</td>
                        <td>com.example.batch.configに左記Javaクラスを作成する。</td>
                    </tr>
                    <tr>
                        <td>com.example.batch.tasklet</td>
                        <td>
                            src/main/java配下に左記パッケージを作成する。
                            <br>
                            Taskletインターフェースを利用して、Hello Worldをログ出力するtaskletを実装する。
                        </td>
                    </tr>
                    <tr>
                        <td>HelloTasklet.java</td>
                        <td>com.example.batch.taskletに左記Javaクラスを作成する。</td>
                    </tr>
                </table>
                <br>
                <ol>
                    <li>HelloTasklet.javaの作成</li>
                    以下の通り、実装する。
                    <br><br>
                    <pre  class="pre-scrollable"><code>
        package com.example.batch.tasklet;
        import org.springframework.batch.core.StepContribution;
        import org.springframework.batch.core.configuration.annotation.StepScope;
        import org.springframework.batch.core.scope.context.ChunkContext;
        import org.springframework.batch.core.step.tasklet.Tasklet;
        import org.springframework.batch.repeat.RepeatStatus;
        import org.springframework.stereotype.Component;
        import lombok.extern.slf4j.Slf4j;
        
        @Component
        @StepScope
        @Slf4j
        
        public class HelloTasklet implements Tasklet{
            
            @Override
            public RepeatStatus execute(StepContribution contribution, 
                    ChunkContext chunkContext) throws Exception {
                log.info("Hello World");
                return RepeatStatus.FINISHED;
            }
        
        }                                
                    </code></pre>
                    <br><br>
                    [ポイント]
                    <ol>
                        <li>
                            Taskletインターフェースを実装することで、taskletを作成することができる。
                            <br>
                            <code>Tasklet.execute(StepContribution, ChunkContext)</code>をオーバーライドすることで、tasletを実装する。
                            <br>
                            <a href src="https://spring.pleiades.io/spring-batch/docs/current/api/org/springframework/batch/core/step/tasklet/Tasklet.html">公式</a>
                            では以下の通り説明されている。
                            <br>
                            ステップコントリビューションの形で現在のコンテキストを前提として、トランザクション内でこのユニットを処理するために必要なことをすべて実行します。完了した場合、実装は RepeatStatus.FINISHED を返します。そうでない場合は RepeatStatus.CONTINUABLE を返します。失敗すると例外がスローされます。
                            <br>
                            パラメーター:
                            <br>
                            contribution - 現在のステップ実行を更新するために戻される変更可能な状態
                            <br>
                            chunkContext - 再起動間ではなく、呼び出し間で共有される属性
                        </li>
                        <br>
                        <li>
                            <code>@StepScope</code>を設定することで、インスタンスのライフサイクルをデフォルト設定のsingletonから変更する。
                            <br>
                            <code>@StepScope</code>により、Stepの開始時にインスタンスが作成され、ステップの完了時にインスタンスが破棄される挙動となる。
                        </li>
                        <br>
                        <li>
                            <code>log.info()</code>は<code>@Slf4j</code>を付与したことで利用できるメソッド。ログの標準出力を行う。
                        </li>
                    </ol>
                    <br>
                    <li>BatchConfig.javaの作成</li>
                    以下の通り、実装する。
                    <br><br>
                    <pre  class="pre-scrollable"><code>
        package com.example.batch.config;
        import org.springframework.batch.core.Job;
        import org.springframework.batch.core.Step;
        import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
        import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
        import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
        import org.springframework.batch.core.launch.support.RunIdIncrementer;
        import org.springframework.batch.core.step.tasklet.Tasklet;
        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.context.annotation.Bean;
        import org.springframework.context.annotation.Configuration;
        
        @Configuration
        @EnableBatchProcessing
        
        public class BatchConfig {
        
            @Autowired
            private JobBuilderFactory jobBuilderFactory;
            
            @Autowired
            private StepBuilderFactory stepBuilderFactory;
            
            @Autowired
            private Tasklet helloTasklet;
            
            @Bean
            public Step taskletStep1() {	
                return stepBuilderFactory.get("HelloTaskletStep1")
                        .tasklet(helloTasklet)
                        .build();		
            }
            
            @Bean
            public Job taskletJob() throws Exception{
                return jobBuilderFactory.get("HelloWorldTaskletjob")
                        .incrementer(new RunIdIncrementer())
                        .start(taskletStep1())
                        .build();
            }
        }            
                    </code></pre>
                    <br><br>
                    [ポイント]
                    <ol>
                        <br>
                        <li>
                            BatchConfig.javaでバッチ処理の作成を行っている。個別に作成したStep処理をまとめてJob化しているイメージとなる。
                            <br>
                            <code>@Configutation</code>と<code>@Bean</code>を利用することでJobとTaskletをBean登録している。
                            <br>
                            Jobがシェルスクリプトなどのトリガーで実行された際は、Springの処理でDIコンテナからインスタンスを取得して処理するものと思慮。
                            <br>このあたりのSpringBatchのアーキテクチャの詳細な解説は
                            <a href src="https://terasoluna-batch.github.io/guideline/5.0.0.RELEASE/ja/single_index.html">Terasolunaの利用ガイド</a>
                            に記載があるため、要チェック。
                            <br>
                            ※Terasolunaの利用ガイドではJobをクラスではなく、XMLファイルで定義している。
                        </li>
                        <br>
                        <li>
                            <code>@EnableBatchProcessing</code>を付与することで、Springバッチの設定に必要なインスタンスをDI出来るようになる。
                            <br>
                            上記ソースでは本アノテーションにより、以下のインスタンスをDIしている。
                            <br>
                            <table class="table">
                                <tr>
                                    <th>インスタンス</th>
                                    <th>説明</th>
                                </tr>
                                <tr>
                                    <td>JobBuilderFactory</td>
                                    <td>
                                        Jobを生成するためのクラス。上記ソースでは
                                        <br>
                                        <code>jobBuilderFactory.get("HelloWorldTaskletjob")
                                        .incrementer(new RunIdIncrementer())
                                        .start(taskletStep1())
                                        .build();</code>
                                        <br>
                                        で「HelloWorldTaskletjob」と命名したジョブを生成している。このジョブには<code>tasukletStep1()</code>で生成したStepが取り込まれている。
                                        <br>
                                        <code>.incrementer(new RunIdIncrementer)</code>は、Jobに一意のIDを割り当てるための処理。
                                        <br>
                                        Job名とJobIdはSpringBatchによりDBに登録され、実行履歴が管理される。JobIdは主キーとなるため、重複違反とならないようにインクリメントする処理が必要となる。
                                        <br>
                                        <code>RunIdIncrementer</code>はSpringBatchが提供するクラスで、このコンストラクタを呼び出すことで、インクリメントの管理をしてくれる。
                                    </td>
                                </tr>
                                <tr>
                                    <td>StepBuilderFactory</td>
                                    <td>
                                        Stepを生成するためのクラス。上記ソースでは、
                                        <br>
                                        <code>public Step taskletStep1() {	
                                            return stepBuilderFactory.get("HelloTaskletStep1")
                                                    .tasklet(helloTasklet)
                                                    .build();</code>
                                        <br>
                                        で「HelloTaskletStep1」と命名したStepを生成している。
                                        <br>
                                        <code>.tasklet(helloTasklet)</code>で、HelloTasklet.javaで作成したクラスに記載されたHelloWorldをログ出力するTaskletを取り込み、Stepを作成している。
                                    </td>
                                </tr>
                            </table>
                        </li>
                    </ol>
                </ol>
                <br>
                続いて、作成したTaskletを実行する。実際の環境では、シェルスクリプトなどからコマンドラインでバッチ処理を呼び出すが、ここではテストのため、STS上から以下の手順でバッチを実行した。
                <ol>
                    <br>
                    <li>
                        プロジェクトを右クリック→実行→Starting Boot アプリケーション                        
                    </li>
                    <br>
                    <img class="img-fluid" src="./image/sts-execute-project1.png" alt="Tasklet実行" title="Tasklet実行">
                    <br><br>
                    <li>
                        コンソールに以下のようにログ出力される。(一部を抜粋)
                        <pre class="pre-scrollable"><code>
        Started SpringBatchSampleApplication in 2.444 seconds (JVM running for 3.358)
        Running default command line with: []
        Job: [SimpleJob: [name=HelloWorldTaskletjob]] launched with the following parameters: [{run.id=1}]
        Executing step: [HelloTaskletStep1]
        Hello World
        Step: [HelloTaskletStep1] executed in 29ms
        Job: [SimpleJob: [name=HelloWorldTaskletjob]] completed with the following parameters: [{run.id=1}] and the following status: [COMPLETED] in 48ms
                        </code></pre>
                        HelloWorldTaskletjobがid=1で実行されたことが分かる。また、HelloTaskletStep1がJobから実行されたことが分かる。
                    </li>
                </ol>
            </ul>
            <ul>
                <h2 id="3-2">3-2.chunkの作成</h2>
                Chunkを使ってHelloWorldをログ出力するサンプルアプリケーションを作成する。
                <br>
                Taskletとは別に、プロジェクトを作成する方針とする。プロジェクトの作成方法はTaskletと同様。
                <br><br>
                [編集するファイル]
                <br>
                <table class="table">
                    <tr>
                        <th>ファイル名</th>
                        <th>説明</th>
                    </tr>
                    <tr>
                        <td>com.example.batch.config</td>
                        <td>src/main/java配下に左記パッケージを作成する。</td>
                    </tr>
                    <tr>
                        <td>BatchConfig.java</td>
                        <td>com.example.batch.configに左記Javaクラスを作成する。</td>
                    </tr>
                    <tr>
                        <td>com.example.batch.chunk</td>
                        <td>
                            src/main/java配下に左記パッケージを作成する。
                            <br>
                        </td>
                    </tr>
                    <tr>
                        <td>HelloProcessor.java</td>
                        <td>com.example.batch.chunkに左記Javaクラスを作成する。</td>
                    </tr>
                    <tr>
                        <td>HelloReader.java</td>
                        <td>com.example.batch.chunkに左記Javaクラスを作成する。</td>
                    </tr>
                    <tr>
                        <td>HelloWriter.java</td>
                        <td>com.example.batch.chunkに左記Javaクラスを作成する。</td>
                    </tr>
                </table>
                <br>    
                <ol>
                    <br>
                    <li>HelloReader.javaの作成</li>
                    以下の通り、実装する。
                    <pre class="pre-scrollable"><code>
        package com.example.batch.chunk;

        import org.springframework.batch.core.configuration.annotation.StepScope;
        import org.springframework.batch.item.ItemReader;
        import org.springframework.batch.item.NonTransientResourceException;
        import org.springframework.batch.item.ParseException;
        import org.springframework.batch.item.UnexpectedInputException;
        import org.springframework.stereotype.Component;
        import lombok.extern.slf4j.Slf4j;

        @Component
        @StepScope
        @Slf4j

        public class HelloReader implements ItemReader<String> {
        
        	private String[] input = {"Hello","World","hoge","fuga",null,"The World"};
        	private int index = 0;
        
        	@Override
        	public String read() throws Exception, UnexpectedInputException, ParseException, NonTransientResourceException{
            
        		String message = input[index++];
        		log.info("Read:()", message);
            
        		return message;
            
        	}
        
        }
                    </code></pre>
                    <br><br>
                    [ポイント]
                    <ol>
                        <br>
                        <li>
                            Taskletと同様に<code>Component</code>と<code>@StepScope</code>を付与し、Bean登録とインスタンス生成のライフサイクルを定義する。
                        </li>
                        <br>
                        <li>
                            Readerを作成するために、ItemReaderインターフェースを実装する。ItemReader内の<code>read()</code>をオーバライドする。
                            
                            <a href src="https://spring.pleiades.io/spring-batch/docs/current/api/org/springframework/batch/item/ItemReader.html">read()のJavaDoc</a>には
                            以下の通り記載されている。
                            <ul>
                                入力データの一部を読み取り、次のデータに進みます。実装は、入力データセットの最後に null を返す必要があります。トランザクション設定では、最初の呼び出しがロールバックされたトランザクション内にあった場合、呼び出し元は連続した呼び出し（またはそれ以外）から同じアイテムを 2 回取得する場合があります。<br>
                                戻り値:<br>
                                T 処理するアイテム、またはデータソースが使い果たされた場合は null <br>
                                例外:<br>
                                ParseException - 現在のレコードの解析に問題がある場合 (しかし、次のものはまだ有効かもしれません)<br>
                                NonTransientResourceException - 基礎となるリソースに致命的な例外がある場合。この例外をスローした後、実装は後続の read 呼び出しから null を返すように努める必要があります。<br>
                                UnexpectedInputException - 入力データに未分類の問題がある場合。潜在的に一時的であると想定します。後続の読み取り呼び出しは成功する可能性があります。<br>
                                java.lang.Exception - 特定のエラーがない場合。
                            </ul>
                            上記ソースでは、プロパティとして定義した<code>input</code>変数に入力された文字列を<code>read()</code>内で<code>input[index++]</code>により順次取り出し、ログ出力している。
                            <br>
                            通常、<code>index[input++]</code>によるデータ取得はfor文で実装する必要があるが、<code>read()</code>をオーバライドすることで、for文が不要かつ、ループ終了の判定の考慮不要となっていると理解。
                        </li>
                        <br>
                        <li>
                            returnは<code>message</code>を返却している。<code>input</code>の内容を1件ずつ処理して、後続のItemProcessorに渡す処理となる。
                        </li>
                    </ol>
                    <br>
                    <li>ItemProcessor.javaの作成</li>
                    以下の通り、実装する。
                    <br><br>
                    <pre class="pre-scrollable"><code>
            package com.example.batch.chunk;
            import org.springframework.batch.core.configuration.annotation.StepScope;
            import org.springframework.batch.item.ItemProcessor;
            import org.springframework.stereotype.Component;
            import lombok.extern.slf4j.Slf4j;
            
            @Component
            @StepScope
            @Slf4j
            
            public class HelloProcessor implements ItemProcessor<String, String>{
                
                @Override
                public String process(String item) throws Exception{
                    
                    item = "item + ★";
                    log.info("Processor:{}", item);
                    return item;
                    
                }
            
            }                        
                    </code></pre>
                    <br><br>
                    [ポイント]
                    <br>
                    <ol>
                        <br>
                        <li>Taskletと同様に<code>Component</code>と<code>@StepScope</code>を付与し、Bean登録とインスタンス生成のライフサイクルを定義する。</li>
                        <br>
                        <li>
                            Processorを作成するために、ItemProcessorインターフェースを実装する。ItemProcessor内の<code>process()</code>をオーバライドする。
                            <br>
                            <a href src="https://spring.pleiades.io/spring-batch/docs/current/api/org/springframework/batch/item/ItemProcessor.html">JavaDoc</a>
                            の記載は以下の通り。
                            <ul>
                                提供されたアイテムを処理し、継続的な処理のために変更された可能性のあるアイテムまたは新しいアイテムを返します。返された結果が null の場合、アイテムの処理は続行されないと見なされます。考えられるソースは次のとおりであるため、null アイテムがこのメソッドに到達することはありません。ItemReader (これ以上のアイテムがないことを示す)
                                複合プロセッサーの以前の ItemProcessor (フィルタリングされたアイテムを示す)<br>
                                パラメーター:<br>
                                item - 処理されるため、null は使用しないでください。<br>
                                戻り値:<br>
                                処理を続行するために潜在的に変更された項目または新しい項目、提供された項目の処理を続行しない場合は null <br>
                                例外:<br>
                                java.lang.Exception - 処理中に例外が発生した場合にスローされます。
                            </ul>
                            上記のソースでは、<code>process(String item)</code>でItemReaderから引き渡された<code>item</code>に★を付与する処理でオーバライドしている。
                            <br>
                            <code>item</code>がItemReaderから引き渡される処理はSpringBatchのフレームワークで制御している理解。
                        </li>
                        <br>
                        <li>
                            加工した<code>item</code>をreturnし、後続のItemWriterに引き渡している。
                        </li>
                    </ol>
                    <br>
                    <li>HelloWriter.javaの作成</li>
                    以下の通り、実装する。
                    <br><br>
                    <pre class="pre-scrollable"><code>
            package com.example.batch.chunk;
            import java.util.List;
            import org.springframework.batch.core.configuration.annotation.StepScope;
            import org.springframework.batch.item.ItemWriter;
            import org.springframework.stereotype.Component;
            import lombok.extern.slf4j.Slf4j;
            
            @Component
            @StepScope
            @Slf4j
            
            public class HelloWriter implements ItemWriter<String> {
                
                @Override
                public void write(List<? extends String>items) throws Exception{
                    log.info("writer:{}",items);
                    log.info("===================");
                }
                
            }            
                    </code></pre>
                    <br><br>
                    [ポイント]
                    <br>
                    <ol>
                        <br>
                        <li>Taskletと同様に<code>Component</code>と<code>@StepScope</code>を付与し、Bean登録とインスタンス生成のライフサイクルを定義する。</li>
                        <br>
                        <li>
                            Writerを作成するために、ItemWriterインターフェースを実装する。ItemWriter内の<code>write()</code>をオーバライドする。
                            <a href src=https://spring.pleiades.io/spring-batch/docs/current/api/org/springframework/batch/item/ItemWriter.html>JavaDoc</a>
                            の記載は以下の通り。
                            <ul>
                                指定されたデータ要素を処理します。通常の操作では null アイテムで呼び出されません。<br>
                                パラメーター:<br>
                                items - 書かれる項目<br>
                                例外:<br>
                                java.lang.Exception - エラーがある場合。フレームワークは例外をキャッチし、必要に応じて変換または再スローします。
                            </ul>
                            上記のソースでは、Processorから引き渡された<code>items</code>をログ出力している。なお、<code>items</code>はProcessorから引き渡された<code>item</code>を複数保持する。<br>
                            このあたりの処理はBatchConfig.javaで制御される。また、<code>&lt;? extends String&gt;</code>はString型の全てのサブクラスを表している。
                            <a href src="https://qiita.com/sukoyakarizumu/items/a95d88e294940c31b6fc">このサイト</a>の解説が分かりやすかった。
                        </li>
                    </ol>
                    <br>
                    <li>BatchConfig.javaの作成</li>
                    以下の通り、実装する。
                    <br><br>
                    <pre class="pre-scrollable"><code>
        package com.example.batch.config;
        import org.springframework.batch.core.Job;
        import org.springframework.batch.core.Step;
        import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
        import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
        import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
        import org.springframework.batch.core.launch.support.RunIdIncrementer;
        import org.springframework.batch.item.ItemProcessor;
        import org.springframework.batch.item.ItemReader;
        import org.springframework.batch.item.ItemWriter;
        import org.springframework.beans.factory.annotation.Autowired;
        import org.springframework.context.annotation.Bean;
        import org.springframework.context.annotation.Configuration;
        
        @Configuration
        @EnableBatchProcessing
        
        public class BatchConfig {
        
            @Autowired
            private JobBuilderFactory jobBuilderFactory;
            
            @Autowired
            private StepBuilderFactory stepBuilderFactory;
            
            @Autowired
            private ItemReader<String> reader;
        
            @Autowired
            private ItemProcessor<String, String> processor;
        
            @Autowired
            private ItemWriter<String> writer;
        
            @Bean
            public Step chunkStep() {	
                return stepBuilderFactory.get("HelloChunkStep")
                        .<String, String>chunk(1)
                        .reader(reader)
                        .processor(processor)
                        .writer(writer)
                        .build();
            }
            
            @Bean
            public Job chunkJob() throws Exception{
                return jobBuilderFactory.get("HelloWorldChunkjob")
                        .incrementer(new RunIdIncrementer())
                        .start(chunkStep())
                        .build();
            }
        }        
                    </code></pre>
                    <br><br>
                    [ポイント]
                    <ol>
                        <br>
                        <li>基本的な構成はtaskletで作成したBatchConfig.javaと同様だが、Chunk特有の設定が含まれている。</li>
                        <br>
                        <li>
                            <code>@Autowired</code>で、作成したItemReader、ItemProcessor、ItemWriterをDIしている。
                        </li>
                        <br>
                        <li>
                            <code>chunkStep()</code>で<code>reader(reader)</code>→<code>processor(processor)</code>→<code>writer(writer)</code>の順番で呼び出している。<br>
                            それぞれの引数にはDIしたインスタンスが渡されている。
                        </li>
                        <br>
                        <li>
                            <code>chunkStep()</code>で<code>&lt;String, String&gt;chunk(1)</code>を定義している。<br>
                            これは<code>&lt;Input, Output&gt;chunk(コミット間隔)</code>を意味する。InputはItemReaderが取り扱うデータ型、OutputはItemWriterが扱うデータ型を表す。
                            また、コミット間隔は一度に処理するデータ件数を表す。上記のソースでは1件ずつ処理する設定としている。
                            <br>
                            コミット間隔を変更すると、例えば、3回、ReaderとProcessorを動かしたあと、実行結果をWriterの<code>items</code>に引き渡し、まとめてデータ出力することになる。
                        </li>
                    </ol>
                </ol>
                <br>
                <br>
                taskletと同様の方法でchunkを実行すると、以下のログ出力が得られる。
                <br>
                [コミット間隔が1の場合]
                <br><br>
                <pre class="pre-scrollable"><code>
        Job: [SimpleJob: [name=HelloWorldChunkjob]] launched with the following parameters: [{run.id=1}]
        Executing step: [HelloChunkStep]
        Read:()
        Processor:Hello★
        writer:[Hello★]
        ===================
        Read:()
        Processor:World★
        writer:[World★]
        ===================
        Read:()
        Processor:hoge★
        writer:[hoge★]
        ===================
        Read:()
        Processor:fuga★
        writer:[fuga★]
        ===================
        Read:()
        Step: [HelloChunkStep] executed in 58ms
            
                </code></pre>
                <br>
                <br>
                [コミット間隔が3の場合]
                <br><br>
                <pre class="pre-scrollable"><code>
        Job: [SimpleJob: [name=HelloWorldChunkjob]] launched with the following parameters: [{run.id=1}]
        Executing step: [HelloChunkStep]
        Read:()
        Read:()
        Read:()
        Processor:Hello★
        Processor:World★
        Processor:hoge★
        writer:[Hello★, World★, hoge★]
        ===================
        Read:()
        Read:()
        Processor:fuga★
        writer:[fuga★]
        ===================
        Step: [HelloChunkStep] executed in 52ms
                </code></pre>
                <br>
                <br>
                taskletを実行した時と同様にJobIdが引数として渡されて、Jobが実行されている。
                <br>
                コミット間隔が1の時は1件ずつ、reader→processor→writerの処理が実行差ているのに対して、
                <br>
                コミット間隔が3の時は3回、readerとprocessorの処理が実行されたのち、witerがまとめて3件のデータを処理していることが分かる。
                <br>
                なお、inputデータは、"Hello","World","hoge","fuga",null,"The World"であったが、上記のログでは、先頭4件しか処理されていない。
                <br>
                これは、ItemReaderの仕様で、<code>null</code>を読み取った場合は後続データが存在しないと判断され、5件目以降のnull,"The World"が処理されないもの。

            </ul>
        </p>
    </div>
</body>
</html>
